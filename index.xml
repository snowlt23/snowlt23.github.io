<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>snowlt23&#39;s website</title>
    <link>https://snowlt23.github.io/</link>
    <description>Recent content on snowlt23&#39;s website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 29 Jan 2018 23:19:05 +0900</lastBuildDate>
    
	<atom:link href="https://snowlt23.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Forthの覚醒 : road to jedi ;</title>
      <link>https://snowlt23.github.io/post/forth-awakening/</link>
      <pubDate>Mon, 29 Jan 2018 23:19:05 +0900</pubDate>
      
      <guid>https://snowlt23.github.io/post/forth-awakening/</guid>
      <description>思いつくままに書いていったら結構長くなってしまいました。Forthでよく言われる考え方について書いてみました。ちなみに考え方の部分は他とは区別するために意図的に「だである」調で書いてます。それではどうぞ。
プログラミング言語Forth
Forthというプログラミング言語がある。マイナー言語探訪を趣味にしていない限り、聞いたことがない人が大半だろう。
初めてForthの名を聞く人は最初にこう思うだろう。「どんな言語なの？」「どんな機能があるの？」と。
これに対する答えは非常に難しいが、あえて答えるなら私はこう答えるだろう。「Problem Oriented Programming Language(問題志向言語)」「あなたが望むであろう機能は一切無い」と。
ちょっとまってくれ、問題志向言語？どんなプログラミング言語も問題を解くためのものじゃないのか？それに欲しい機能が無いって、それは使う価値がある言語なのか？それはおもちゃ言語ではないのか？
おそらくこういう反応が帰ってくるであろう。その見方はもっともだ。どんな言語も問題を解くためのものだし、機能が無い言語は現実的な問題には使いづらいと感じるのも仕方ない。
しかし、それは既存のプログラミング言語によって形成された価値観のもとでの見方でしかない。ForthにはForthなりの考え方(Forth way)がある。
郷に入っては郷に従えということで、今回の記事ではそれについて語っていきたいと思う。
Forth入門 Forthがどんな見た目をしていて、どんな動作をするのかが他のプログラミング言語をやってきた人にはわかりやすいはずなので、まずはForthの動作を見ていこうと思う。
Forthで1 + 1をするプログラムは以下だ。
4 5 +  おそらく+を後ろに書くことに違和感を覚える人が殆どだろう。これは逆ポーランド記法と言われる書き方で、殆どの言語が演算子を中置にするのに対して、Forthでは後置にする。(反対にLispは前置) ただ記法中心に考えるのはここではあまり意味をなさない。それはForth wayではない。ここで重要なのは今書いたプログラムの動作だ。
ここで書いたプログラムは以下のような動作をする。
4をスタックに積む -&amp;gt; 5をスタックに積む -&amp;gt; スタックから2つの値を取り出し足し合わせる  スタックはプログラマならとても馴染みの深いデータ構造だ。スタックには積む(push)動作と取り出す(pop)動作の2つがある。この2つの動作を中心としてデータを扱う。
ここで重要なのは、Forthはスタックとともに処理が進行していく言語だということだ。上記のただ足し合わせるプログラムでもスタックを使って処理が進行する。多くのプログラミング言語では通常スタックを意識することは少ないだろう。(内部的には使われているのだが) 多くのプログラミング言語では足し合わせる処理は左の値と右の値を引数として+関数に渡すという処理の流れをとることが多い。
なんでこんな面倒なことをするんだろう？と思った方は多いのではないだろうか。このForthの動作は、プログラムを単純な関数の並びとして分割することを可能にする。先程の例に戻ろう。
4をスタックに積む -&amp;gt; 5をスタックに積む -&amp;gt; スタックから2つの値を取り出し足し合わせる  このプログラムの見方を変えるとこうなる。
4という関数を呼び出す -&amp;gt; 5という関数を呼び出す -&amp;gt; +という関数を呼び出す  そう、ただ関数を並べて順繰りに呼び出しているだけだ。そして関数がそれぞれスタックに値を積んだり取り出したりして処理が進行していく。そこには式や文といった概念は存在せず、ただスタック操作を行う関数呼び出しに完結するプログラムができる。(ちなみにForthでは関数とは呼んだりせずword(単語)と呼ぶことが殆どだ)(つまりForthのプログラムは単なる単語の羅列だ(dictionary(辞書)ともいう)
この動作はコンピュータの動作原理を反映したものである。プログラミング言語はコンピュータで動くものを作るためのものと教わることは多いかと思うが、実際には多くのプログラミング言語はコンピュータの動作原理をそのまま反映したものではない。多くのプログラミング言語は形式言語から出発しており、人が読みやすい(と思われている)自然言語へと近づけることに努力されてきたように思う。そしてそれをコンピュータで動く形式へと翻訳する処理系を通じて動くという仕組みだ。 しかし、Forthは自然言語へと近づけることを選択せず、あくまでコンピュータの動作原理に沿うことを選んだ。Forthはプログラミング言語ではなくリッチアセンブラだと言われることもあるが、これは大体正しいと思う。
しかしアセンブラでプログラミングしたいという人はどれだけいるだろうか？おそらく殆どいないんじゃないだろうかと思う。しかしアセンブラでプログラミングをしたいと思えないのは、それに抽象化能力が欠けているからだ。Forthはアセンブラのようなものと言われることがある。しかし、Forthにはどの言語にも負けない強力な抽象化能力がある。
: add5 5 + ;  これはただ5を足すだけの関数(word)だ。:で関数定義の開始、;で関数定義の終了だ。しかし、Forthでの関数(word)には2つの種類がある。通常のwordと、もう一つがimmediate wordだ。
immediate wordにするには以下のようにする。
: add5 5 + ; immediate  追加されたimmediateもwordだ。これは最も新しく定義されたwordのフラグを書き換える作用がある。(ちなみに:と;もwordだ。関数定義のための特殊構文に見えるかもしれないが、順々に実行されているにすぎない)</description>
    </item>
    
    <item>
      <title>Supercon2017参加記</title>
      <link>https://snowlt23.github.io/post/supercon2017/</link>
      <pubDate>Sun, 24 Dec 2017 05:20:09 +0900</pubDate>
      
      <guid>https://snowlt23.github.io/post/supercon2017/</guid>
      <description>この記事は N高等学校 Advent Calendar 2017 24日目のポエムです。
今更ですが今年の8月頃に開催されたSupercomputing Contest 2017(SuperCon)に参加した記録でも書こうと思います。
本当はFloriという自作言語の記事を書きたかったのですが処理系の実装が目標の段階まで到達できなかったので代わりにこちらを。
SuperConとは http://www.gsic.titech.ac.jp/supercon/main/attwiki/index.php
東京工業大学と大阪大学が主催するスーパーコンピューターを使っていい感じに問題を解くコンテストです。５日間(実質4日)かけて解くのでいわゆるマラソン？
事の発端 唐突にSuperCon出ない？とプロたちから誘われる。この時点では競技プログラミング自体は全くの門外漢だったのでどうしようかと戸惑いながらも面白そうなので出てみることにした。ちなみに後でなぜ誘ったのか聞いたらN高等学校学内Slackの#programmingチャンネル見てたら強そうだからという雑な理由だった。
予選 SuperConの予選はクセ無し種合成問題というものだった。競技プログラミングの門外漢でアルゴリズムに弱い僕はなんか適当な全探索みたいなのを書いて終わった気がする。
なおチームメイトのプロがビームサーチとか使ってめっちゃいい感じのコードを生成してくれたことにより予選を突破できた。:pray:
本戦前 地方勢なので東京まで飛行機で行った。なお東京自体はそこそこ慣れてたので特に問題はなかった。
前日に学校のプログラミング勢+講師で競プロ合宿をした。なお僕は飛行機の関係上途中参加。
本戦の前日の深夜に大阪大学関係で検索したらなんかめっちゃいい感じのSX-ACEの資料が出てきたので慌てて重要そうなところをメモる(SX-ACEはSuperCon2017で使うスパコン)
本戦 (ここからがメイン) 本戦問題 本戦の問題は音楽データの圧縮をする問題だった。圧縮といっても色々な圧縮アルゴリズムで片っ端から小さくしろという問題ではなく、PCMデータを音の定数分の上下で表す非可逆圧縮をするという問題。今回求めなくてはならないのはより元の音源を再現できる定数と上下の配列。
で、その圧縮の際に利用するのが大阪大学に導入されているスーパーコンピュータであるSX-ACE。SX-ACEはベクトル型計算機というもので、ざっくりいうと配列に対して同じような処理を複数回適用する際にベクトル化していい感じに高速に計算できる。今回のコンテストはスパコンがメインのコンテストなので、これを有効活用しないといけない。
本戦開始 1日目 とりあえず３人でそれぞれ別な感じの方針でいくことに。この時僕は何を書いたかあまり覚えていない（なんかその時点ではそこそこスコア出てたけどすぐにプロに抜かれて完全に忘却の彼方へいってしまった）
2日目 プロが三分探索とかを使ってめっちゃいい感じのスコアを出す。ここからこれを改良していく方針になる。 これを改良していって特にすることがなくなっていた。わりと３人共暇（２人はもとから暇）になってくる。
この時点でプロがDP解を思いついたらしいが実装がやばいらしく一旦保留。
3日目 プロが気合でDP解の実装をする。なんかめっちゃやばいスコアが出て３人で笑ってた。しかしこの時点で大きな問題があって、DPでも計算量がめちゃめちゃ重くてすごい小さな音楽データでないと時間内に計算しおわらない。
そこで僕はプロが実装したDP解の高速化に取り掛かった。ようやくまともな仕事をすることになる。 ここでさらに問題発生。プロが実装したDPにバグがあることが発覚。プロは気合でデバッグを開始。
高速化の話 (申し訳程度の技術情報) そして僕の高速化はめちゃめちゃ上手く行った。なんかぽんぽんと速度が見違えるように速くなってそこそこ小さめの問題なら解ける程度の速度まで持っていけた。普段はC,Rust,Nimみたいなシステムプログラミング言語とかばかり触っているおかげだろうか。
ちなみにここでした最適化は、主にメモリレイアウトへのアクセスの調整とベクトル化の２つ。
メモリは基本的にCPUに比べると遅いハードなのでメモリからCPUのキャッシュへ上手く載せることが重要になる。で、メモリからキャッシュに載せる際にメモリからは必要なデータだけでなくその周辺のデータもキャッシュへ読み込まれる。なので、連続でアクセスするデータがメモリとして連続しているとメモリアクセスが超高速化されてハッピーということだ。
具体的には、
int arr[100][1000];  という配列が合った時に、
for (int j=0; j&amp;lt;1000; j++) { for (int i=0; i&amp;lt;100; i++) { process(arr[i][j]); } }  とするよりも、
for (int i=0; i&amp;lt;100; i++) { for (int j=0; j&amp;lt;1000; j++) { process(arr[i][j]); } }  としたほうが高速になるという具合だ。こうすることにより連続したメモリ領域へのアクセスとなり、メモリアクセスの際に上手くキャッシュに載りかなり高速化される。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://snowlt23.github.io/about/</link>
      <pubDate>Sun, 24 Dec 2017 05:03:42 +0900</pubDate>
      
      <guid>https://snowlt23.github.io/about/</guid>
      <description> snowlt23 (Shunsuke Ogata)  プログラマ N高等学校生徒 2016年度N予備校ドワンゴインターン生 Superconputing Contest 2017 4位 Age: 20  Skills  プログラミング言語  Forth Nim C JavaScript  言語処理系 低レイヤー 最適化 WASM  Products  Twim (Twitter Image Downloader Chrome拡張(WASM)) nim-peheader (PEヘッダパーサ) wasm-bench-site (WASMベンチマークサイト)  Socials  Github: https://github.com/snowlt23 Twitter: https://twitter.com/snowlt23 Qiita: https://qiita.com/snowlt23  </description>
    </item>
    
  </channel>
</rss>