<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Forthの覚醒 : road to jedi ;</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Forthの覚醒 : road to jedi ;">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="Forthの覚醒 : road to jedi ;">
	<meta name="twitter:description" content="">
	<meta name="twitter:site" content="@snowlt23">
	<meta name="twitter:creator" content="@snowlt23">
	<meta name="twitter:image:src" content="">
	
	
	<meta name="og:title" content="Forthの覚醒 : road to jedi ;">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://snowlt23.github.io/post/forth-awakening/">
	<meta name="og:site_name" content="Forthの覚醒 : road to jedi ;">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="snowlt23">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	<script src="/js/caption.js"></script>
</head>
<body>

<header >
	<a href="/" style="float: left;color:#777;"><strong>snowlt23&#39;s website</strong>
	</a>
	<a href="/index.xml" style="color:#777;float: left;"><strong>
		&nbsp;
	<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>
</strong></a>
<a href="https://snowlt23.github.io/about/" style="color:#777;"><strong>About</strong></a>

</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
    	el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
	<h1>Forthの覚醒 : road to jedi ; <aside></aside></h1>
	

<p>思いつくままに書いていったら結構長くなってしまいました。Forthでよく言われる考え方について書いてみました。ちなみに考え方の部分は他とは区別するために意図的に「だである」調で書いてます。それではどうぞ。</p>

<hr />

<p><strong>プログラミング言語Forth</strong></p>

<p>Forthというプログラミング言語がある。マイナー言語探訪を趣味にしていない限り、聞いたことがない人が大半だろう。<br />
初めてForthの名を聞く人は最初にこう思うだろう。「どんな言語なの？」「どんな機能があるの？」と。<br />
これに対する答えは非常に難しいが、あえて答えるなら私はこう答えるだろう。「Problem Oriented Programming Language(問題志向言語)」「あなたが望むであろう機能は一切無い」と。<br />
ちょっとまってくれ、問題志向言語？どんなプログラミング言語も問題を解くためのものじゃないのか？それに欲しい機能が無いって、それは使う価値がある言語なのか？それはおもちゃ言語ではないのか？<br />
おそらくこういう反応が帰ってくるであろう。その見方はもっともだ。どんな言語も問題を解くためのものだし、機能が無い言語は現実的な問題には使いづらいと感じるのも仕方ない。<br />
しかし、それは既存のプログラミング言語によって形成された価値観のもとでの見方でしかない。ForthにはForthなりの考え方(Forth way)がある。<br />
郷に入っては郷に従えということで、今回の記事ではそれについて語っていきたいと思う。</p>

<h2 id="forth入門">Forth入門</h2>

<p>Forthがどんな見た目をしていて、どんな動作をするのかが他のプログラミング言語をやってきた人にはわかりやすいはずなので、まずはForthの動作を見ていこうと思う。</p>

<p>Forthで<code>1 + 1</code>をするプログラムは以下だ。</p>

<pre><code>4 5 +
</code></pre>

<p>おそらく<code>+</code>を後ろに書くことに違和感を覚える人が殆どだろう。これは逆ポーランド記法と言われる書き方で、殆どの言語が演算子を中置にするのに対して、Forthでは後置にする。(反対にLispは前置)
ただ記法中心に考えるのはここではあまり意味をなさない。それは<strong>Forth way</strong>ではない。ここで重要なのは今書いたプログラムの動作だ。<br />
ここで書いたプログラムは以下のような動作をする。</p>

<pre><code>4をスタックに積む -&gt; 5をスタックに積む -&gt; スタックから2つの値を取り出し足し合わせる
</code></pre>

<p>スタックはプログラマならとても馴染みの深いデータ構造だ。スタックには積む(push)動作と取り出す(pop)動作の2つがある。この2つの動作を中心としてデータを扱う。<br />
ここで重要なのは、Forthはスタックとともに処理が進行していく言語だということだ。上記のただ足し合わせるプログラムでもスタックを使って処理が進行する。多くのプログラミング言語では通常スタックを意識することは少ないだろう。(内部的には使われているのだが)  多くのプログラミング言語では足し合わせる処理は左の値と右の値を引数として+関数に渡すという処理の流れをとることが多い。<br />
なんでこんな面倒なことをするんだろう？と思った方は多いのではないだろうか。このForthの動作は、プログラムを単純な関数の並びとして分割することを可能にする。先程の例に戻ろう。</p>

<pre><code>4をスタックに積む -&gt; 5をスタックに積む -&gt; スタックから2つの値を取り出し足し合わせる
</code></pre>

<p>このプログラムの見方を変えるとこうなる。</p>

<pre><code>4という関数を呼び出す -&gt; 5という関数を呼び出す -&gt; +という関数を呼び出す
</code></pre>

<p>そう、ただ関数を並べて順繰りに呼び出しているだけだ。そして関数がそれぞれスタックに値を積んだり取り出したりして処理が進行していく。そこには式や文といった概念は存在せず、ただスタック操作を行う関数呼び出しに完結するプログラムができる。(ちなみにForthでは関数とは呼んだりせずword(単語)と呼ぶことが殆どだ)(つまりForthのプログラムは単なる単語の羅列だ(dictionary(辞書)ともいう)</p>

<p>この動作はコンピュータの動作原理を反映したものである。プログラミング言語はコンピュータで動くものを作るためのものと教わることは多いかと思うが、実際には多くのプログラミング言語はコンピュータの動作原理をそのまま反映したものではない。多くのプログラミング言語は形式言語から出発しており、人が読みやすい(と思われている)自然言語へと近づけることに努力されてきたように思う。そしてそれをコンピュータで動く形式へと翻訳する処理系を通じて動くという仕組みだ。
しかし、Forthは自然言語へと近づけることを選択せず、あくまでコンピュータの動作原理に沿うことを選んだ。Forthはプログラミング言語ではなくリッチアセンブラだと言われることもあるが、これは大体正しいと思う。</p>

<p>しかしアセンブラでプログラミングしたいという人はどれだけいるだろうか？おそらく殆どいないんじゃないだろうかと思う。しかしアセンブラでプログラミングをしたいと思えないのは、それに抽象化能力が欠けているからだ。Forthはアセンブラのようなものと言われることがある。しかし、Forthにはどの言語にも負けない強力な抽象化能力がある。</p>

<pre><code>: add5
  5 +
;
</code></pre>

<p>これはただ5を足すだけの関数(word)だ。<code>:</code>で関数定義の開始、<code>;</code>で関数定義の終了だ。しかし、Forthでの関数(word)には2つの種類がある。通常のwordと、もう一つがimmediate wordだ。<br />
immediate wordにするには以下のようにする。</p>

<pre><code>: add5
  5 +
; immediate
</code></pre>

<p>追加されたimmediateもwordだ。これは最も新しく定義されたwordのフラグを書き換える作用がある。(ちなみに<code>:</code>と<code>;</code>もwordだ。関数定義のための特殊構文に見えるかもしれないが、順々に実行されているにすぎない)<br />
immediate wordとは何なのか？それはコンパイル時に動作するwordだ。</p>

<pre><code>: main
  4 add5
;
</code></pre>

<p>上記のmain wordでは、mainが実行されたときに4に5を足して9にするというのが期待される動作のはずだ。しかし、immediate wordにするとコンパイル時にwordが動作する。つまりmainというwordを定義している最中にadd5 wordが実行される。</p>

<p>こんなことができて何が嬉しいのか？察しのいい方ならもうすでにお気づきだと思うが、そう。メタプログラミングができるのである。<br />
これはただ単に5を足すというなんの面白みも無いプログラムだが、コンパイル時にwordが動作するということは、コードを生成するwordを作って、それをimmediate wordにしてやれば、自在にプログラムを生成することができる。プログラムを生成することが可能になれば、自在にプログラムの抽象度をコントロールすることができる。</p>

<h2 id="forth哲学">Forth哲学</h2>

<p>ここで話題を変えて、大胆な主張をしてみたいと思う。(実際にはForth作者のチャールズ・ムーアの受け売りだが)</p>

<ul>
<li>変数は使うな</li>
<li>コードの共有をするな</li>
<li>憶測するな</li>
</ul>

<p>これを見て多くの人は「真剣に言ってるの？変数を使わないプログラムなんて書けないよ！それにコードは再利用するものでしょ？」と思うだろう。<br />
ここにはちゃんとした考え方がある。ここで一番重視される考え方は<strong>シンプルさ</strong>だ。
シンプルさとは一体何なんだろうか？まずは、簡単という意味ではない。</p>

<p>ここでの考え方は、</p>

<ul>
<li>問題を解くための最小限の適合したプログラム</li>
<li>プログラム全体が理解でき、動作を検証することができる</li>
</ul>

<p>あたりだろうか。上記の3つの主張はこれらのためにある。</p>

<p>変数は多くのプログラミング言語の中心概念であるように思う。しかしForth作者のチャールズ・ムーアはこのような考え方を持っている。</p>

<pre><code>変数を使わなければいけないコードを書いている時点で、関数に分割することを考慮するべきです。
</code></pre>

<p>変数を使わないという制約のもとでは、非常に短く、簡潔な関数定義へと繋がる。これは自身でForthを書いてみることで実感したが、変数を使わないプログラミングは、頭を使うが、それと同時に非常に綺麗で細かな関数定義へと分割される美しさを感じた。Forthでは多くのwordは1~3行で定義され、長くても6行程度となっている。そして変数というものが無くなって読みにくいかと思われたソースコードが、綺麗に分割され、非常に読みやすくなっていることに気づく。これは体験してみないとわかりにくいと思うので、気になった方はぜひForthを書いてみてほしい。</p>

<p>コード共有をするなとはどういうことだろうか。チャールズ・ムーアとしての考え方は、「汎用的に作られたプログラムは、膨大で理解しづらく、そしてあなた自身の問題に適合しない」とのことだ。<br />
あなた自身が書いた自分の問題を解くためのプログラムは、高度に適合し、また、非常に小さく簡潔で、少ないコンピュータリソースで動くものが出来上がる。<br />
ちなみにここで憶測をしないことも重要になってくる。あなたは未来を予知することはできない。だから、実現するかもわからない未来のためのコードを書くべきではない。ということだ。不必要なコードはプログラムを肥大化させ、また、負債化することが多い。</p>

<h2 id="forth-programming-language">Forth Programming Language</h2>

<p>Forthは機能が無い(正確に言うと最小限の)プログラミング言語である。しかし、強力な抽象化能力を備えている。
前述のForth哲学と照らし合わせると、Forthは「問題を解くための言語を定義するための言語」ということだ。つまり、「自分のことは自分でやれ」ということに尽きる。
Forthはプログラマに最大限の自由を与える代わりに、プログラマに全ての責任を委ねる。Forthには型が無い(動的型付けではなくて、型という概念そのものが無い)し、最近のGoやRustみたいな安全で気の利いた機能もない。</p>

<p>つまり、Forthではあなたが全てを決めるのだ。そこには言語の制約や機能が邪魔をすることは一切無い。これを自由と見るか危険と見るか不便と見るかはプログラマ次第かも知れないが、他のプログラミング言語と違って非常にユニークだということは多くの人に同意してもらえると思う。</p>

<p>Forthは、問題に適合することを選んだ言語なのだ。</p>

<hr />

<h2 id="実用的な話">実用的な話</h2>

<p>まぁなんか色々書きましたが、つまり言いたいのはForthは問題に適合するための<strong>言語を作る言語</strong>という側面が強いということです。<br />
Forthの言語的な特徴としては、</p>

<ul>
<li>Simple</li>
<li>Small</li>
<li>Fast</li>
<li>Interactive</li>
<li>Modular</li>
</ul>

<p>あたりでしょうか。Interactiveとかは結構重要で、Forthコードを書いてすぐ試したり、プログラムが動いている最中に動的にプログラムを生成したりとか色々自由なことができます。</p>

<p>また、Smallというのも現代の言語の多くで失われた特徴で、Forthプログラムは非常に小さくなることが多く、また、言語が単純なので組み込み環境の少ないメモリでもコンパイラ全てが収まる容量にすることが可能です。なのでForthを組み込み環境で動かしてる人はそこそこ見かけます。他のインタラクティブな言語の多く(SmalltalkやCommon Lispなど)は全てを含めたイメージにすると結構巨大になってしまうのですが、Forthは現代でもSmallさを保っています。
あとプログラムが小さいということは人にとってもメリットがあって、単純に1人の脳に全てがおさまるプログラムになるというメリットもあります。人間にもコンピュータみたいなメモリがあると思っていて、あまりにも複雑なプログラムだとプログラム全体について考えることを阻害するように思います。<br />
特に自分は一般的なメジャー言語の多くでプログラムする際は結構ストレスがあって、単純に言語自体が巨大な言語が多いので、パーサですら脳内に入りきらない感覚をうけます。それに対してForthは言語全体が人間のL1キャッシュに載りきるサイズのような感覚です。<br />
これはいわゆる標準ライブラリをあるていど暗記するようなもので、必ずしもやる必要はないが、やるのとやらないのではコーディング速度に影響が出て、最終的な成果物にも影響が出る感覚です。</p>

<p>Forth哲学はRui Ueyamaさんがブログに書かれている考え方にも近いように思います。こういった考え方はForthだけでなくソフトウェア開発に普遍的に見られるものとも言えるかもしれません。<br />
Link -&gt;</p>

<ul>
<li><a href="http://blog.sigbus.info/2014/12/blog-post_29.html">すべてのソースコードが手元にあるのに不要な抽象化を行うのはよくない</a></li>
<li><a href="http://blog.sigbus.info/2014/12/blog-post_28.html">正しくオブジェクト指向できているどうかという意味のない議論</a></li>
<li><a href="http://blog.sigbus.info/2014/11/blog-post.html">作りたいものを作るには結局大量のコードを書かないといけないことについて</a></li>
<li><a href="http://blog.sigbus.info/2015/01/blog-post_29.html">コードを削除したら喜ぶべき。知らない人がみたら意味不明なコードが残っていませんか？</a></li>
</ul>

<h2 id="処理系">処理系</h2>

<p>Forth処理系は数あるプログラミング言語の中でもトップクラスに処理系が作りやすいプログラミング言語なので、色々処理系があったりします。(まったく名前を聞いたことのないチップで動く処理系とかも見かけます)
ですが、とりあえずこれを使っておけばOK的な処理系は無いなぁという印象を受けました。<br />
自分が試した中で、WindowsやLinuxといった標準OSで動かす場合の処理系は以下がおすすめです。</p>

<ul>
<li>gForth (GNUのForth)</li>
<li>SwiftForth (商用Forth。無期限使用可能な評価版があるので試してみるといいかも)</li>
<li><a href="https://github.com/larsbrinkhoff/lbForth">lbForth</a> (Forthのセルフホスティングコンパイラ。targetの数が非常に多く、x86だけでなくavrやarm、さらにasmjsとかまである。処理系のソースコードを読むとForth自体の勉強になると思います)</li>
</ul>

<p>ちなみに今自分自身でForth処理系を作ってみてます。現状でも標準ライブラリはある程度動くところまではいったので折を見て公開する予定です。(多分単純な最適化実装できたあたりかな)</p>

<h2 id="文献">文献</h2>

<p>日本語の情報が本当に少ないので英語メインにはなりますが、色々見た感じ以下がおすすめです。(というか英語でも本当に情報が少ない・・・)</p>

<ul>
<li><a href="https://qiita.com/takl/items/e28c3298a0a043edeaa6">Qiita: 一日でできるセルフホスティングForthコンパイラ</a>

<ul>
<li>貴重な日本語情報。超おすすめです。これをきっかけにForthの楽しさを知りました。ただx86_x64アセンブラとかに抵抗あるときついかも。</li>
</ul></li>
<li><a href="https://forth-standard.org/">Forth Standard</a>

<ul>
<li>Forthの基本的なwordや実装、テストコードなどが載ってるのでどういった動作をするかや、処理系を作る場合などに参考になります。</li>
</ul></li>
<li><a href="https://www.quora.com/What-makes-Forth-more-powerful-than-Lisp">What makes Forth more powerful than Lisp?</a>

<ul>
<li>Andreas Klimasさんという方の回答が面白いです。この人の他の回答も面白いのでそちらも見てみるといいかもしれません。</li>
</ul></li>
<li><a href="http://fujim.tumblr.com/post/361291349/forth%E9%96%A2%E9%80%A3%E3%81%AE%E6%83%85%E5%A0%B1%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81">Forth関連の情報サイトのまとめ</a>

<ul>
<li>こちらにも情報がまとまっているのでおすすめです。</li>
</ul></li>
</ul>

<h2 id="方言">方言</h2>

<p>ちなみに言語自体がシンプルで作りやすいからか方言もいろいろ生まれてます。<br />
方言で有名なのは動的型付けのFactorと静的型付けのKittenでしょうか。これらはForthの影響を受けてますが全く違う言語なのでこちらもやってみると面白いかもしれません。</p>

<hr />

<p>Forthすごい良い言語だなぁと思ったんですが、あまりにも情報が少なすぎたので色々書いてみました。
Forthは面白い言語なので言語自体のHackな記事とかも書いてみたいですね。ForthでWebAssemblyいじりとかやったりしてるので、それもできれば記事にしたいです。<br />
明日から仕事で使える知識/技術/言語というわけでは絶対に無いですが、まぁ楽しみのためだとか、はたまたガチで使ってみるのもいいんじゃないかなぁとか思います。 Good Luck Have Hack :)</p>

<h2 id="追記">追記</h2>

<p>知り合いからForthのimmediate wordの動作が気になると指摘されたので、Forth処理系がどんなプロセスで処理を進行させるか書こうと思います。</p>

<p>Forthでは<code>:</code>wordでcompilation stateというものに入ります。コンパイル状態ということですね。反対に<code>;</code>でcompilation stateから抜けます。<br />
このcompilation stateでのword呼び出しは、そのwordを呼び出す機械語コードやVMコードに変換されます。しかし、このwordがimmediate wordであった場合、呼び出しコードに変換する代わりにその場でwordを実行します。こうすることでword定義の中でwordの実行が可能になります。<br />
C言語など多くの言語では、ソースコードをコンパイル-&gt;リンク-&gt;実行ファイル-&gt;実行という流れをとることが多いですが、Forthではword1つ1つを呼び出すたびにコードの生成が行われ、実行が可能になります。ある意味ではJITコンパイラとも呼ぶことができますね。</p>

</div>




	<p><small><em>Written January 29, 2018. </em>
		 
		Send feedback to <a  href="https://twitter.com/intent/tweet?text=%40snowlt23%20%23postforth-awakening%20">@snowlt23</a>.
		
	</small></p>

	<p>
	<a href="/post/supercon2017/">← Supercon2017参加記</a>&nbsp;
	
	</p>









</body>
</html>
